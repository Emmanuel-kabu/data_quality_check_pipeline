"""
Notification Module
===================
Sends alerts via Slack, Email, and PagerDuty based on pipeline events.
Supports tiered notification routing:
  - CRITICAL: PagerDuty + Slack + Email to engineering
  - WARNING:  Slack + Email to governance team
  - INFO:     Slack only
"""

import json
import logging
import smtplib
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from typing import Any

from src.config import NOTIFICATION_CONFIG

logger = logging.getLogger(__name__)


class Notifier:
    """Sends notifications through configured channels."""

    def __init__(self) -> None:
        self.notification_log: list[dict] = []

    # ------------------------------------------------------------------
    # Slack notifications
    # ------------------------------------------------------------------
    def send_slack(self, message: str, severity: str = "INFO") -> bool:
        """Send a Slack notification via webhook."""
        config = NOTIFICATION_CONFIG["slack"]
        if not config["enabled"]:
            logger.debug("Slack notifications disabled -- skipping")
            return False

        webhook_url = config["webhook_url"]
        if not webhook_url:
            logger.warning("Slack webhook URL not configured")
            return False

        severity_emoji = {
            "CRITICAL": ":rotating_light:",
            "HIGH": ":warning:",
            "MEDIUM": ":large_yellow_circle:",
            "LOW": ":information_source:",
            "INFO": ":white_check_mark:",
            "SUCCESS": ":tada:",
        }

        emoji = severity_emoji.get(severity, ":memo:")
        payload = {
            "channel": config["channel"],
            "username": "Data Quality Pipeline",
            "icon_emoji": ":bar_chart:",
            "blocks": [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": f"{emoji} Data Quality Alert — {severity}",
                    },
                },
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": message,
                    },
                },
                {
                    "type": "context",
                    "elements": [
                        {
                            "type": "mrkdwn",
                            "text": f"Pipeline | {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}",
                        }
                    ],
                },
            ],
        }

        try:
            import urllib.request
            req = urllib.request.Request(
                webhook_url,
                data=json.dumps(payload).encode("utf-8"),
                headers={"Content-Type": "application/json"},
            )
            with urllib.request.urlopen(req, timeout=10) as resp:
                success = resp.status == 200
                self._log_notification("slack", severity, message, success)
                return success
        except Exception as exc:
            logger.error("Failed to send Slack notification: %s", exc)
            self._log_notification("slack", severity, message, False, str(exc))
            return False

    # ------------------------------------------------------------------
    # Email notifications
    # ------------------------------------------------------------------
    def send_email(
        self,
        subject: str,
        body: str,
        severity: str = "INFO",
        recipient_group: str = "warning",
    ) -> bool:
        """Send an email notification."""
        config = NOTIFICATION_CONFIG["email"]
        if not config["enabled"]:
            logger.debug("Email notifications disabled -- skipping")
            return False

        recipients = config["recipients"].get(recipient_group, [])
        recipients = [r.strip() for r in recipients if r.strip()]
        if not recipients:
            logger.warning("No email recipients for group: %s", recipient_group)
            return False

        try:
            msg = MIMEMultipart("alternative")
            msg["Subject"] = f"[{severity}] {subject}"
            msg["From"] = config["sender"]
            msg["To"] = ", ".join(recipients)

            # Plain text body
            msg.attach(MIMEText(body, "plain"))

            # HTML body
            html_body = f"""
            <html>
            <body>
            <h2 style="color: {'red' if severity == 'CRITICAL' else 'orange'};">
                Data Quality Alert - {severity}
            </h2>
            <pre>{body}</pre>
            <hr>
            <p style="color: gray; font-size: 12px;">
                Generated by Data Quality Pipeline at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
            </p>
            </body>
            </html>
            """
            msg.attach(MIMEText(html_body, "html"))

            with smtplib.SMTP(config["smtp_host"], config["smtp_port"]) as server:
                server.starttls()
                server.login(config["sender"], config["password"])
                server.sendmail(config["sender"], recipients, msg.as_string())

            self._log_notification("email", severity, subject, True)
            logger.info("Email sent to %s: %s", recipient_group, subject)
            return True
        except Exception as exc:
            logger.error("Failed to send email: %s", exc)
            self._log_notification("email", severity, subject, False, str(exc))
            return False

    # ------------------------------------------------------------------
    # PagerDuty notifications
    # ------------------------------------------------------------------
    def send_pagerduty(self, summary: str, severity: str = "critical") -> bool:
        """Trigger a PagerDuty incident for critical failures."""
        config = NOTIFICATION_CONFIG["pagerduty"]
        if not config["enabled"]:
            logger.debug("PagerDuty notifications disabled -- skipping")
            return False

        routing_key = config["routing_key"]
        if not routing_key:
            logger.warning("PagerDuty routing key not configured")
            return False

        pd_severity = "critical" if severity in ("CRITICAL", "HIGH") else "warning"

        payload = {
            "routing_key": routing_key,
            "event_action": "trigger",
            "payload": {
                "summary": summary,
                "source": "data-quality-pipeline",
                "severity": pd_severity,
                "timestamp": datetime.now().isoformat(),
                "custom_details": {
                    "pipeline": "Data Quality Governance",
                    "severity": severity,
                },
            },
        }

        try:
            import urllib.request
            req = urllib.request.Request(
                "https://events.pagerduty.com/v2/enqueue",
                data=json.dumps(payload).encode("utf-8"),
                headers={"Content-Type": "application/json"},
            )
            with urllib.request.urlopen(req, timeout=10) as resp:
                success = resp.status == 202
                self._log_notification("pagerduty", severity, summary, success)
                return success
        except Exception as exc:
            logger.error("Failed to send PagerDuty alert: %s", exc)
            self._log_notification("pagerduty", severity, summary, False, str(exc))
            return False

    # ------------------------------------------------------------------
    # Unified notification dispatcher
    # ------------------------------------------------------------------
    def notify(self, message: str, severity: str = "INFO", subject: str = "") -> None:
        """
        Route notifications based on severity:
          CRITICAL → PagerDuty + Slack + Email (critical team)
          HIGH     → Slack + Email (warning team)
          MEDIUM   → Slack
          LOW/INFO → Slack (if enabled)
        """
        subject = subject or f"Data Quality Pipeline - {severity}"

        if severity == "CRITICAL":
            self.send_pagerduty(message, severity)
            self.send_slack(message, severity)
            self.send_email(subject, message, severity, "critical")
        elif severity == "HIGH":
            self.send_slack(message, severity)
            self.send_email(subject, message, severity, "warning")
        elif severity == "MEDIUM":
            self.send_slack(message, severity)
        else:
            self.send_slack(message, severity)

    def notify_pipeline_success(self, summary: str) -> None:
        """Send success notification."""
        self.notify(summary, severity="SUCCESS", subject="Pipeline Completed Successfully")

    def notify_pipeline_failure(self, error: str) -> None:
        """Send critical failure notification."""
        self.notify(
            f"Pipeline FAILED:\n{error}",
            severity="CRITICAL",
            subject="Pipeline Failure - Immediate Action Required",
        )

    def notify_threshold_breach(self, failure_pct: float, threshold: float) -> None:
        """Send threshold breach notification."""
        self.notify(
            f"Validation failure rate {failure_pct:.1f}% exceeds threshold {threshold:.1f}%.\n"
            f"Pipeline halted. Manual review required.",
            severity="CRITICAL",
            subject="Validation Threshold Breach",
        )

    def notify_human_review_needed(self, details: str) -> None:
        """Send notification that human review is required."""
        self.notify(
            f"Human review required:\n{details}",
            severity="HIGH",
            subject="Manual Review Required",
        )

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------
    def _log_notification(
        self,
        channel: str,
        severity: str,
        message: str,
        success: bool,
        error: str = "",
    ) -> None:
        """Record a notification attempt."""
        self.notification_log.append({
            "channel": channel,
            "severity": severity,
            "message": message[:200],
            "success": success,
            "error": error,
            "timestamp": datetime.now().isoformat(),
        })
